# キャッシュ実装のUX・コスト影響分析

## 概要

本プロジェクトでは **Cloudflare Cache API** を使用して以下のデータをキャッシュしています：

1. **トークン状態データ** (`token.getState`): R2から取得するJSON（TTL: 60秒）
2. **マーケットキャップデータ** (`mc.getMarketCaps`): Dexscreener API呼び出し結果（TTL: 60秒）
3. **R2 JSONオブジェクト** (`r2.getJson`): R2から取得するJSON（TTL: 60秒）
4. **R2バイナリデータ** (`/api/r2/[...key]`): 画像などのバイナリ（TTL: 60秒）

## 重要な前提

**Cloudflare Cache APIはWorkersの無料枠に含まれるため、キャッシュ自体に追加コストは発生しません。**

キャッシュの効果は以下に現れます：

- **R2 Class Bオペレーション（GetObject）の削減**
- **外部API（Dexscreener）呼び出しの削減**
- **レスポンス時間の短縮（UX向上）**

---

## シナリオ別コスト試算

### シナリオ1: 小規模（月間10万PV）

**前提条件:**

- 月間ページビュー: 100,000 PV
- 1PVあたりのリクエスト内訳:
  - `/api/trpc/mc.getMarketCaps`: 1回（全トークンのマーケットキャップ）
  - `/api/trpc/token.getState`: 平均3回（表示されるトークン画像、全8トークンのうち一部）
  - `/api/r2/[...key]` (画像): 4回（メイン画像 + サムネイル等）
  - `/api/trpc/r2.getJson`: 1回（グローバル状態など）

**月間リクエスト数:**

- tRPCリクエスト: 100,000 × (1 + 3 + 1) = 500,000回
- R2画像リクエスト: 100,000 × 4 = 400,000回
- **合計: 900,000回**

#### キャッシュなしの場合

**R2 Class Bオペレーション:**

- `mc.getMarketCaps`: 0回（外部APIのみ、R2アクセスなし）
- `token.getState`: 100,000 × 3 = 300,000回（3トークン分）
- `r2.getJson`: 100,000 × 1 = 100,000回
- `/api/r2/[...key]`: 400,000回
- **合計: 800,000回**

**外部API呼び出し:**

- Dexscreener API: 100,000回（`mc.getMarketCaps`、8トークン分のAPI呼び出し）

**コスト計算:**

- Workersリクエスト: 900,000回 → 無料枠内（10M/月）
- R2 Class B: 800,000回 → 無料枠内（10M/月）
- **追加コスト: $0**

#### キャッシュありの場合（ヒット率60%想定）

**キャッシュヒット率の根拠:**

- TTLが60秒のため、60秒以内の同一リクエストはヒット
- リアルタイム更新が必要なデータだが、60秒のキャッシュは許容範囲
- 想定ヒット率: 60%（保守的見積もり）
- 画像は比較的長期間変わらないため、ヒット率は高め（70-80%想定）
- マーケットキャップは頻繁に変わるため、ヒット率は低め（40-50%想定）

**実際のR2 Class Bオペレーション:**

- `token.getState`: 300,000 × 0.4 = 120,000回（画像データ、中程度のヒット率）
- `r2.getJson`: 100,000 × 0.4 = 40,000回
- `/api/r2/[...key]`: 400,000 × 0.3 = 120,000回（画像、高いヒット率想定）
- **合計: 280,000回**

**外部API呼び出し:**

- Dexscreener API: 100,000 × 0.5 = 50,000回（マーケットキャップ、低めのヒット率）

**コスト計算:**

- Workersリクエスト: 900,000回 → 無料枠内
- R2 Class B: 280,000回 → 無料枠内
- **追加コスト: $0**

**削減効果:**

- R2 Class B削減: 520,000回（65%削減）
- 外部API削減: 50,000回（50%削減）

---

### シナリオ2: 中規模（月間100万PV）

**前提条件:**

- 月間ページビュー: 1,000,000 PV
- リクエスト内訳はシナリオ1と同様

**月間リクエスト数:**

- tRPCリクエスト: 5,000,000回
- R2画像リクエスト: 4,000,000回
- **合計: 9,000,000回**

#### キャッシュなしの場合

**R2 Class Bオペレーション:**

- `token.getState`: 3,000,000回
- `r2.getJson`: 1,000,000回
- `/api/r2/[...key]`: 4,000,000回
- **合計: 8,000,000回**

**外部API呼び出し:**

- Dexscreener API: 1,000,000回

**コスト計算:**

- Workersリクエスト: 9,000,000回 → 無料枠内
- R2 Class B: 8,000,000回 → 無料枠内
- **追加コスト: $0**

#### キャッシュありの場合（ヒット率60%）

**実際のR2 Class Bオペレーション:**

- `token.getState`: 3,000,000 × 0.4 = 1,200,000回
- `r2.getJson`: 1,000,000 × 0.4 = 400,000回
- `/api/r2/[...key]`: 4,000,000 × 0.3 = 1,200,000回
- **合計: 2,800,000回**

**外部API呼び出し:**

- Dexscreener API: 1,000,000 × 0.5 = 500,000回

**コスト計算:**

- Workersリクエスト: 9,000,000回 → 無料枠内
- R2 Class B: 2,800,000回 → 無料枠内
- **追加コスト: $0**

**削減効果:**

- R2 Class B削減: 5,200,000回（65%削減）
- 外部API削減: 500,000回（50%削減）
- **コスト削減: $0（無料枠内のため）**

---

### シナリオ3: 大規模（月間500万PV）

**前提条件:**

- 月間ページビュー: 5,000,000 PV
- リクエスト内訳はシナリオ1と同様

**月間リクエスト数:**

- tRPCリクエスト: 25,000,000回
- R2画像リクエスト: 20,000,000回
- **合計: 45,000,000回**

#### キャッシュなしの場合

**R2 Class Bオペレーション:**

- `token.getState`: 15,000,000回
- `r2.getJson`: 5,000,000回
- `/api/r2/[...key]`: 20,000,000回
- **合計: 40,000,000回**

**外部API呼び出し:**

- Dexscreener API: 5,000,000回

**コスト計算:**

- Workersリクエスト: 45,000,000回 → **35,000,000回超過**
  - 超過分: 35,000,000 / 1,000,000 × $0.30 = **$10.50/月**
- R2 Class B: 40,000,000回 → **30,000,000回超過**
  - 超過分: 30,000,000 / 1,000,000 × $0.36 = **$10.80/月**
- **総コスト: $21.30/月**

#### キャッシュありの場合（ヒット率60%）

**実際のR2 Class Bオペレーション:**

- `token.getState`: 15,000,000 × 0.4 = 6,000,000回
- `r2.getJson`: 5,000,000 × 0.4 = 2,000,000回
- `/api/r2/[...key]`: 20,000,000 × 0.3 = 6,000,000回
- **合計: 14,000,000回**

**外部API呼び出し:**

- Dexscreener API: 5,000,000 × 0.5 = 2,500,000回

**コスト計算:**

- Workersリクエスト: 45,000,000回 → **35,000,000回超過**
  - 超過分: $10.50/月
- R2 Class B: 14,000,000回 → **4,000,000回超過**
  - 超過分: 4,000,000 / 1,000,000 × $0.36 = **$1.44/月**
- **総コスト: $11.94/月**

**削減効果:**

- R2 Class B削減: 26,000,000回（65%削減）
- 外部API削減: 2,500,000回（50%削減）
- **コスト削減: $9.36/月（44%削減）**

---

### シナリオ4: 超大規模（月間2000万PV）

**前提条件:**

- 月間ページビュー: 20,000,000 PV
- リクエスト内訳はシナリオ1と同様

**月間リクエスト数:**

- tRPCリクエスト: 100,000,000回
- R2画像リクエスト: 80,000,000回
- **合計: 180,000,000回**

#### キャッシュなしの場合

**R2 Class Bオペレーション:**

- `token.getState`: 60,000,000回
- `r2.getJson`: 20,000,000回
- `/api/r2/[...key]`: 80,000,000回
- **合計: 160,000,000回**

**外部API呼び出し:**

- Dexscreener API: 20,000,000回

**コスト計算:**

- Workersリクエスト: 180,000,000回 → **170,000,000回超過**
  - 超過分: 170,000,000 / 1,000,000 × $0.30 = **$51.00/月**
- R2 Class B: 160,000,000回 → **150,000,000回超過**
  - 超過分: 150,000,000 / 1,000,000 × $0.36 = **$54.00/月**
- **総コスト: $105.00/月**

#### キャッシュありの場合（ヒット率60%）

**実際のR2 Class Bオペレーション:**

- `token.getState`: 60,000,000 × 0.4 = 24,000,000回
- `r2.getJson`: 20,000,000 × 0.4 = 8,000,000回
- `/api/r2/[...key]`: 80,000,000 × 0.3 = 24,000,000回
- **合計: 56,000,000回**

**外部API呼び出し:**

- Dexscreener API: 20,000,000 × 0.5 = 10,000,000回

**コスト計算:**

- Workersリクエスト: 180,000,000回 → **170,000,000回超過**
  - 超過分: $51.00/月
- R2 Class B: 56,000,000回 → **46,000,000回超過**
  - 超過分: 46,000,000 / 1,000,000 × $0.36 = **$16.56/月**
- **総コスト: $67.56/月**

**削減効果:**

- R2 Class B削減: 104,000,000回（65%削減）
- 外部API削減: 10,000,000回（50%削減）
- **コスト削減: $37.44/月（36%削減）**

---

## UXへの影響

### レスポンス時間の改善

**キャッシュなしの場合:**

- R2 GetObject: 平均50-100ms（レイテンシ）
- Dexscreener API: 平均200-500ms（外部API）
- **合計: 250-600ms**

**キャッシュありの場合:**

- Cache API: 平均1-5ms（メモリアクセス）
- **改善: 249-595ms短縮（99%以上改善）**

### 可用性の向上

- **外部API障害時の影響軽減**: Dexscreener APIがダウンしても、キャッシュがあれば60秒間はサービス継続可能
- **R2障害時の影響軽減**: R2が一時的に利用不可でも、キャッシュがあればサービス継続可能
- **レート制限回避**: 外部APIのレート制限に引っかかりにくくなる

### 同時リクエスト処理の改善

`getOrSet`関数の**in-flight deduplication**により：

- 同じキーへの同時リクエストが複数来ても、実際の計算は1回だけ実行
- レースコンディションを防止
- サーバー負荷を削減

---

## キャッシュヒット率の感度分析

### ヒット率30%の場合（保守的）

**シナリオ3（500万PV）:**

- R2 Class B削減: 22,500,000回（30%削減）
- コスト削減: $8.10/月（24%削減）

### ヒット率80%の場合（楽観的）

**シナリオ3（500万PV）:**

- R2 Class B削減: 60,000,000回（80%削減）
- コスト削減: $21.60/月（64%削減）

### ヒット率の要因

1. **TTL（60秒）**: 短いほどヒット率は下がるが、データの鮮度は保たれる
2. **アクセスパターン**: 同じユーザーが短時間に再訪問する頻度
3. **コンテンツの更新頻度**: トークン状態やマーケットキャップの変化頻度

---

## 結論

### コスト面での効果

| シナリオ | 月間PV | キャッシュなし | キャッシュあり | 削減額 | 削減率 |
| -------- | ------ | -------------- | -------------- | ------ | ------ |
| 小規模   | 10万   | $0             | $0             | $0     | -      |
| 中規模   | 100万  | $0             | $0             | $0     | -      |
| 大規模   | 500万  | $21.30         | $11.94         | $9.36  | 44%    |
| 超大規模 | 2000万 | $105.00        | $67.56         | $37.44 | 36%    |

**重要なポイント:**

- **中規模（100万PV）以上でコスト削減効果が明確に現れる**
- **大規模になるほど削減額が大きくなる**
- **キャッシュ自体に追加コストは発生しない**（Cloudflare Cache APIは無料）

### UX面での効果

1. **レスポンス時間**: 99%以上短縮（250-600ms → 1-5ms）
2. **可用性**: 外部API/R2障害時の影響軽減
3. **スケーラビリティ**: 同時リクエスト処理の改善

### 推奨事項

1. **現在の実装で十分**: TTL 60秒は適切なバランス
2. **モニタリング**: 実際のヒット率を計測して最適化
3. **段階的なTTL調整**: データの性質に応じてTTLを調整可能にする
   - 画像: より長いTTL（300秒など）も検討可能
   - マーケットキャップ: 現在の60秒が適切

### 今後の最適化の余地

1. **TTLの動的調整**: データの更新頻度に応じてTTLを変更
2. **キャッシュキーの最適化**: より細かい粒度でのキャッシュ
3. **プリフェッチ**: 次のリクエストを予測して事前キャッシュ

---

## 補足: Cloudflare Cache APIについて

- **無料枠**: Workersの無料枠に含まれる（追加コストなし）
- **制限**: 特に明示的な制限はないが、実質的にはWorkersのリソース制限内
- **パフォーマンス**: メモリベースの高速アクセス（1-5ms）
- **永続性**: キャッシュは一時的で、TTL後に自動削除

**KVとの違い:**

- Cache API: 一時的なキャッシュ、無料、高速
- KV: 永続的なストレージ、課金あり、やや遅い（10-50ms）

現在の実装では**Cache APIが最適**です。
